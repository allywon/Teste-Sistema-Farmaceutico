unit Routes.Manager;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections,
  IdHTTPServer, IdCustomHTTPServer, IdContext, Routes.Interfaces, ModelDB;

type
  TRouteManager = class
  private
    FServer: TIdHTTPServer;
    FRoutes: TList<IRoute>;
    FModelDB: TModelDB;
  public
    constructor Create(AServer: TIdHTTPServer; AModelDB: TModelDB);
    destructor Destroy; override;

    procedure RegistrarRotas;
    function ProcessarRequisicao(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo): Boolean;

    property Routes: TList<IRoute> read FRoutes;
  end;

implementation

uses
  Routes.Status, Routes.Procedimento, Routes.Paciente;

{ TRouteManager }

constructor TRouteManager.Create(AServer: TIdHTTPServer; AModelDB: TModelDB);
begin
  inherited Create;
  FServer := AServer;
  FModelDB := AModelDB;
  FRoutes := TList<IRoute>.Create;

  // Registra as rotas
  FRoutes.Add(TStatusRoute.Create(FServer));
  FRoutes.Add(TProcedimentoRoute.Create(FServer, FModelDB));
  FRoutes.Add(TPacienteRoute.Create(FServer, FModelDB));
end;

destructor TRouteManager.Destroy;
var
  Route: IRoute;
begin
  for Route in FRoutes do
    Route := nil; // Libera as referências

  FRoutes.Free;
  inherited;
end;

procedure TRouteManager.RegistrarRotas;
var
  Route: IRoute;
begin
  WriteLn('Endpoints disponíveis:');
  for Route in FRoutes do
    Route.RegistrarRotas;
end;

function TRouteManager.ProcessarRequisicao(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo): Boolean;
var
  Route: IRoute;
  Path: string;
  Verb: THTTPVerb;
  RouteBase: TRouteBase;
begin
  Result := False;
  Path := ARequestInfo.URI;

  // Converte RouteBase para obter o método utilitário
  RouteBase := TRouteBase.Create(FServer);
  try
    Verb := RouteBase.ObterVerboHTTP(ARequestInfo.Command);
  finally
    RouteBase.Free;
  end;

  // Processa cada rota registrada
  for Route in FRoutes do
  begin
    Result := Route.ProcessarRota(Path, Verb, ARequestInfo, AResponseInfo);
    if Result then
      Break;
  end;

  // Se nenhuma rota processou, retorna 404
  if not Result then
  begin
    AResponseInfo.ResponseNo := 404;
    AResponseInfo.ContentText := '{"error":"Endpoint não encontrado"}';
    Result := True;
  end;
end;

end.
