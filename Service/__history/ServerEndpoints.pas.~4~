unit ServerEndpoints;

interface

uses
  System.SysUtils, System.Classes, IdHTTPServer, IdCustomHTTPServer,
  IdContext, System.JSON, IdGlobal, IdCoderMIME, IdURI;

type
  THTTPVerb = (hvGET, hvPOST, hvPUT, hvDELETE, hvOPTIONS);

  TServerEndpoints = class
  private
    FServer: TIdHTTPServer;

    procedure OnCommand(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    procedure ProcessarRequisicao(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    procedure ConfigurarCORS(AResponseInfo: TIdHTTPResponseInfo);

    function ObterVerboHTTP(const Method: string): THTTPVerb;
    function ExtrairParamPath(const URL: string; Indice: Integer): string;

    // Roteamento
    procedure RotaStatus(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);

    procedure RotaProcedimentos(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    procedure RotaProcedimentosPorTipo(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo; const TipoStr: string);
    procedure RotaProcedimentoById(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo; const Id: string);
    procedure RotaCriarProcedimento(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
  public
    constructor Create;
    destructor Destroy; override;

    procedure Iniciar(const Porta: Integer = 8080);
    procedure Parar;

    property Server: TIdHTTPServer read FServer;
  end;

var
  FServerEndpoints: TServerEndpoints;

implementation

uses
  ModelDB, Procedimento.Controller, Model.Procedimento.Tipo;

var
  FProcedimentoController: TProcedimentoController;

{ TServerEndpoints }

constructor TServerEndpoints.Create;
begin
  FServer := TIdHTTPServer.Create(nil);
  FServer.OnCommandGet := OnCommand;
  FServer.OnCommandOther := OnCommand;

  FProcedimentoController := TProcedimentoController.Create(DBModel);
end;

destructor TServerEndpoints.Destroy;
begin
  FProcedimentoController.Free;
  if Assigned(FServer) then
  begin
    if FServer.Active then
      FServer.Active := False;
    FServer.Free;
  end;
  inherited;
end;

procedure TServerEndpoints.Iniciar(const Porta: Integer);
begin
  FServer.DefaultPort := Porta;
  FServer.Active := True;

  WriteLn('Servidor HTTP iniciado na porta ' + IntToStr(Porta));
  WriteLn('Endpoints disponíveis:');
  WriteLn('GET    /api/status');
  WriteLn('GET    /api/procedimentos');
  WriteLn('GET    /api/procedimentos/:id');
  WriteLn('GET    /api/procedimentos/tipo/:tipo');
  WriteLn('POST   /api/procedimentos');
  WriteLn('PUT    /api/procedimentos/:id');
  WriteLn('DELETE /api/procedimentos/:id');
end;

procedure TServerEndpoints.Parar;
begin
  if FServer.Active then
  begin
    FServer.Active := False;
    WriteLn('Servidor HTTP encerrado');
  end;
end;

procedure TServerEndpoints.OnCommand(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
begin
  try
    AResponseInfo.ContentType := 'application/json; charset=UTF-8';
    ConfigurarCORS(AResponseInfo);

    if SameText(ARequestInfo.Command, 'OPTIONS') then
    begin
      AResponseInfo.ResponseNo := 200;
      Exit;
    end;

    ProcessarRequisicao(ARequestInfo, AResponseInfo);
  except
    on E: Exception do
    begin
      AResponseInfo.ResponseNo := 500;
      AResponseInfo.ContentText := Format('{"error":"Erro interno: %s"}', [E.Message]);
    end;
  end;
end;

procedure TServerEndpoints.ProcessarRequisicao(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
var
  lPath, lIdParam: string;
  lVerbo: THTTPVerb;
begin
  lPath := ARequestInfo.URI;
  lVerbo := ObterVerboHTTP(ARequestInfo.Command);

  if not DBModel.FDConnection.Connected then
    DBModel.ConectarBanco;

  if lPath = '/api/status' then
    RotaStatus(ARequestInfo, AResponseInfo)
  else if lPath = '/api/procedimentos' then
  begin
    case lVerbo of
      hvGET: RotaProcedimentos(ARequestInfo, AResponseInfo);
      hvPOST: RotaCriarProcedimento(ARequestInfo, AResponseInfo);
    else
      AResponseInfo.ResponseNo := 405;
    end;
  end
  else if lPath.StartsWith('/api/procedimentos/tipo/') then
  begin
    lIdParam := ExtrairParamPath(lPath, 4);
    RotaProcedimentosPorTipo(ARequestInfo, AResponseInfo, lIdParam);
  end
  else if lPath.StartsWith('/api/procedimentos/') then
  begin
    lIdParam := ExtrairParamPath(lPath, 3);
    RotaProcedimentoById(ARequestInfo, AResponseInfo, lIdParam);
  end
  else
  begin
    AResponseInfo.ResponseNo := 404;
    AResponseInfo.ContentText := '{"error":"Endpoint não encontrado"}';
  end;
end;

procedure TServerEndpoints.ConfigurarCORS(AResponseInfo: TIdHTTPResponseInfo);
begin
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Origin'] := '*';
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Methods'] := 'GET, POST, PUT, DELETE, OPTIONS';
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Headers'] := 'Content-Type, Authorization';
end;

function TServerEndpoints.ObterVerboHTTP(const Method: string): THTTPVerb;
begin
  if SameText(Method, 'GET') then Result := hvGET
  else if SameText(Method, 'POST') then Result := hvPOST
  else if SameText(Method, 'PUT') then Result := hvPUT
  else if SameText(Method, 'DELETE') then Result := hvDELETE
  else if SameText(Method, 'OPTIONS') then Result := hvOPTIONS
  else Result := hvGET;
end;

function TServerEndpoints.ExtrairParamPath(const URL: string; Indice: Integer): string;
var
  lPartes: TArray<string>;
begin
  Result := '';
  lPartes := URL.Split(['/']);
  if (Indice >= 0) and (Indice < Length(lPartes)) then
    Result := lPartes[Indice];
end;

procedure TServerEndpoints.RotaStatus(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
var
  lObj: TJSONObject;
begin
  lObj := TJSONObject.Create;
  try
    lObj.AddPair('status', 'online');
    lObj.AddPair('version', '1.0.0');
    lObj.AddPair('database', BoolToStr(DBModel.FDConnection.Connected, True));
    lObj.AddPair('timestamp', FormatDateTime('yyyy-mm-dd hh:nn:ss', Now));
    AResponseInfo.ResponseNo := 200;
    AResponseInfo.ContentText := lObj.ToJSON;
  finally
    lObj.Free;
  end;
end;

procedure TServerEndpoints.RotaProcedimentos(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
begin
  AResponseInfo.ResponseNo := 200;
  AResponseInfo.ContentText := FProcedimentoController.ObterProcedimentos.ToJSON;
end;

procedure TServerEndpoints.RotaProcedimentosPorTipo(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo; const TipoStr: string);
var
  lTipo: TTipoProcedimento;
  lInt: Integer;
begin
  if TryStrToInt(TipoStr, lInt) then
  begin
    lTipo := TTipoProcedimento(lInt);
    AResponseInfo.ResponseNo := 200;
    AResponseInfo.ContentText := FProcedimentoController.ObterProcedimentoPorTipo(lTipo).ToJSON;
  end
  else
  begin
    AResponseInfo.ResponseNo := 400;
    AResponseInfo.ContentText := '{"error":"Tipo inválido"}';
  end;
end;

procedure TServerEndpoints.RotaProcedimentoById(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo; const Id: string);
var
  lId: Int64;
  lBody: TJSONObject;
  lTipo: TTipoProcedimento;
  lDescricao: string;
  lValor: Currency;
begin
  if not TryStrToInt64(Id, lId) then
  begin
    AResponseInfo.ResponseNo := 400;
    AResponseInfo.ContentText := '{"error":"ID inválido"}';
    Exit;
  end;

  case ObterVerboHTTP(ARequestInfo.Command) of
    hvGET:
      begin
        AResponseInfo.ResponseNo := 200;
        AResponseInfo.ContentText := FProcedimentoController.ObterProcedimentoPorId(lId).ToJSON;
      end;
    hvPUT:
      begin
        lBody := TJSONObject.ParseJSONValue(ARequestInfo.PostStream) as TJSONObject;
        if Assigned(lBody) then
        try
          lTipo := TTipoProcedimento(lBody.GetValue<Integer>('tipo'));
          lDescricao := lBody.GetValue<string>('descricao');
          lValor := lBody.GetValue<Currency>('valor');

          if FProcedimentoController.AtualizarProcedimento(lId, lTipo, lDescricao, lValor) then
          begin
            AResponseInfo.ResponseNo := 200;
            AResponseInfo.ContentText := '{"success":true}';
          end
          else
            AResponseInfo.ResponseNo := 500;
        finally
          lBody.Free;
        end;
      end;
    hvDELETE:
      begin
        if FProcedimentoController.ExcluirProcedimento(lId) then
        begin
          AResponseInfo.ResponseNo := 200;
          AResponseInfo.ContentText := '{"success":true}';
        end
        else
        begin
          AResponseInfo.ResponseNo := 400;
          AResponseInfo.ContentText := '{"error":"Não foi possível excluir"}';
        end;
      end;
  else
    AResponseInfo.ResponseNo := 405;
  end;
end;

procedure TServerEndpoints.RotaCriarProcedimento(ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
var
  lBody: TJSONObject;
  lTipo: TTipoProcedimento;
  lDescricao: string;
  lValor: Currency;
begin
  lBody := TJSONObject.ParseJSONValue(ARequestInfo.PostStream) as TJSONObject;
  if Assigned(lBody) then
  try
    lTipo := TTipoProcedimento(lBody.GetValue<Integer>('tipo'));
    lDescricao := lBody.GetValue<string>('descricao');
    lValor := lBody.GetValue<Currency>('valor');

    if FProcedimentoController.InserirProcedimento(lTipo, lDescricao, lValor) then
    begin
      AResponseInfo.ResponseNo := 201;
      AResponseInfo.ContentText := '{"success":true}';
    end
    else
      AResponseInfo.ResponseNo := 500;
  finally
    lBody.Free;
  end
  else
  begin
    AResponseInfo.ResponseNo := 400;
    AResponseInfo.ContentText := '{"error":"JSON inválido"}';
  end;
end;

end.

